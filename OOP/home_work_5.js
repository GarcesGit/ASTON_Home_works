/*
Базовый:
1. Перечислить какие бывают алгоритмы сортировок?

1) Сортировка пузырьком (англ. Bubble sort).	Проходит по массиву, сравнивает последовательные пары элементов и меняет их местами, если они расположены в неправильном порядке.	Время исполнения в среднем - O(n^2)
2) Сортировка перемешиванием (англ. Cocktail sort).	Двунаправленный, оптимизированный вариант сортировки пузырьком.	Время исполнения в среднем - O(n^2)
3) Сортировка вставками (англ. Insertion sort).	Элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.	Время исполнения в среднем - O(n^2)
4) Гномья сортировка (англ. Gnome sort).	Гибрид сортировок вставками и пузырьком.	Время исполнения в среднем - O(n^2)
5) Сортировка слиянием (англ. Merge sort).	Рекурсивно сортирует половины массива, а затем комбинирует их в один.	Время исполнения в среднем - O(n log n)
6) Сортировка с помощью двоичного дерева (англ. Tree sort).	На основе исходных данных строится двоичное дерево поиска, в котором последовательно собираются минимальные значения.	Время исполнения в среднем - O(n log n)
7) Сортировка Timsort (англ. Timsort).	Гибрид сортировок вставками и слиянием. Основан на предположении, что при решении практических задач входной массив зачастую состоит из отсортированных подмассивов.	Время исполнения в среднем - O(n log n)
8) Сортировка выбором (англ. Selection sort).	Делит входной массив на упорядоченную и неупорядоченную части. Затем последовательно переносит в первую часть наименьшие элементы из второй.	Время исполнения в среднем - O(n^2)
19) Сортировка расчёской (англ. Comb sort. 	Модификация сортировки пузырьком, в которой расстояние между сравниваемыми парами значений отлично от 1.	Время исполнения в среднем - O(n^2)
10) Сортировка Шелла (англ. Shell sort).	Модификация сортировки вставками, в которой расстояние между сравниваемыми парами значений отлично от 1.	Время исполнения в среднем - O(n log^2 n)
11) Пирамидальная сортировка (сортировка кучи, Heapsort).	На основе исходных данных строится двоичная куча, в которой последовательно собираются минимальные значения.	Время исполнения в среднем - O(n log n)
12) Плавная сортировка (англ. Smoothsort).	Модификация пирамидальной сортировки, оптимизирующая сортировку частично упорядоченного массива.	Время исполнения в среднем - O(n log n)
13) Быстрая сортировка (англ. Quicksort).	Выбирается опорный элемент p. Все ключи меньшие p перемещаются влево от него, а все ключи большие либо равные p, вправо. Далее алгоритм рекурсивно применяется к каждой из частей.	Время исполнения в среднем - O(n log n)
14) Интроспективная сортировка (англ. Introsort). 	Гибрид быстрой и пирамидальной сортировок.	Время исполнения в среднем - O(n log n)
15) Придурковатая сортировка (англ. Stooge sort).	Меняет местами первый и последний элементы массива, если необходимо. Затем делит массив на три части, в каждой из которых запускается рекурсивно.	Время исполнения в среднем - O(n^2.709)
16) Bogosort.	Массив произвольно перемешивается до тех пор, пока не окажется отсортированным.	Время исполнения в среднем - O(n!)
17) Сортировка перестановкой.	Генерируются все возможные последовательности массива, из которых выбирается упорядоченная.	Время исполнения в среднем - O(n!)
18) Гравитационная сортировка (англ. Bead sort).	Числа представляются в виде бусинок на штырях, затем сортируются под действием гравитации.	Время исполнения в среднем - O(n^2)
19) Блочная сортировка (англ. Bucket sort).	Элементы распределяются по блокам согласно диапазону значений, каждый из которых затем рекурсивно сортируется.	Время исполнения в среднем - O(n^2)
20) Поразрядная сортировка (англ. Radix sort).	Массив сортируется согласно с помощью поразрядного сравнения чисел.	Время исполнения в среднем - O(wn)
21) Сортировка подсчётом (англ. Counting sort).	Подсчитывается количество вхождений каждого целого числа из диапазона ключей в массив. Затем выводится значения всех ненулевых значений.	Время исполнения в среднем - O(n+k)
*/

// 2. Создать объект Person несколькими способами, после создать объект AnotherPerson, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

// способ 1
class Person {}
const person = new Person();
person.name = "Ivan";
person.surname = "Ivanov";

// способ 2
class Person {
    name = "Ivan";
    surname = "Ivanov";
}
const person = new Person();

// способ 3
class Person {
    constructor(name, surname) {
        this.name = name;
        this.surname = surname;
    }
}
const person = new Person("Ivan", "Ivanov");

const anotherPerson = Object.create(person, {
    name: { value: "Ivan" },
    surname: { value: "Petrov" },
});

Person.prototype.logInfo = function () {
    return this.name + " " + this.surname;
};

// 3. Создать класс SuperPerson c get и set для поля name и конструктором, сделать класс наследник от класса SuperPerson.

class SuperPerson {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
}
class SuperMan extends SuperPerson {}

const man = new SuperMan("Petr");

// Продвинутый:
// 1. Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

function firstSum(arr, total) {
    for (let i = 0; i < arr.length; i++) {
        let addNum = total - arr[i];

        if (arr.includes(addNum)) {
            return [arr[i], addNum];
        }
    }
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
console.log(firstSum(arr, total)); // [4, 9]

/* 
2. Оценить сложность вашего алгоритма для функции firstSum (хотя бы пару строк в качестве объяснения).

Цикл for имеет линейную временную сложность O(n).
Как вычислили старшие товарищи) Array.prototype.include() имеет временную сложность O(n).
Поэтому сложность функции равна O(n).
*/
